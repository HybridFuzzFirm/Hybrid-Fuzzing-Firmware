#ifndef __OSI_EXT_H__
#define __OSI_EXT_H__
/*
 * DO NOT MODIFY. This file is automatically generated by scripts/apigen.py,
 * based on the <plugin>_int.h file in your plugin directory.
 *
 * Note: Function pointers for API calls are declared as extern.
 * The definition of the pointers is guarded by the PLUGIN_MAIN macro.
 * This plugin is defined only for the compilation unit matching the
 * name of the plugin.
 * This allows us to initialize API function pointers once, in the main
 * compilation unit, rather than in every compilation unit.
 */
#include <dlfcn.h>
#include "panda/plugin.h"

typedef OsiProcs *(*get_processes_t)(CPUState *env);
extern get_processes_t __get_processes;
#ifdef PLUGIN_MAIN
get_processes_t __get_processes = NULL;
#endif
static inline OsiProcs * get_processes(CPUState *env);
static inline OsiProcs * get_processes(CPUState *env) {
    assert(__get_processes);
    return __get_processes(env);
}

typedef OsiProc *(*get_current_process_t)(CPUState *env);
extern get_current_process_t __get_current_process;
#ifdef PLUGIN_MAIN
get_current_process_t __get_current_process = NULL;
#endif
static inline OsiProc * get_current_process(CPUState *env);
static inline OsiProc * get_current_process(CPUState *env) {
    assert(__get_current_process);
    return __get_current_process(env);
}

typedef OsiModules *(*get_modules_t)(CPUState *env);
extern get_modules_t __get_modules;
#ifdef PLUGIN_MAIN
get_modules_t __get_modules = NULL;
#endif
static inline OsiModules * get_modules(CPUState *env);
static inline OsiModules * get_modules(CPUState *env) {
    assert(__get_modules);
    return __get_modules(env);
}

typedef OsiModules *(*get_libraries_t)(CPUState *env, OsiProc *p);
extern get_libraries_t __get_libraries;
#ifdef PLUGIN_MAIN
get_libraries_t __get_libraries = NULL;
#endif
static inline OsiModules * get_libraries(CPUState *env, OsiProc *p);
static inline OsiModules * get_libraries(CPUState *env, OsiProc *p) {
    assert(__get_libraries);
    return __get_libraries(env,p);
}

typedef void(*free_osiproc_t)(OsiProc *p);
extern free_osiproc_t __free_osiproc;
#ifdef PLUGIN_MAIN
free_osiproc_t __free_osiproc = NULL;
#endif
static inline void free_osiproc(OsiProc *p);
static inline void free_osiproc(OsiProc *p) {
    assert(__free_osiproc);
    return __free_osiproc(p);
}

typedef void(*free_osiprocs_t)(OsiProcs *ps);
extern free_osiprocs_t __free_osiprocs;
#ifdef PLUGIN_MAIN
free_osiprocs_t __free_osiprocs = NULL;
#endif
static inline void free_osiprocs(OsiProcs *ps);
static inline void free_osiprocs(OsiProcs *ps) {
    assert(__free_osiprocs);
    return __free_osiprocs(ps);
}

typedef void(*free_osimodules_t)(OsiModules *ms);
extern free_osimodules_t __free_osimodules;
#ifdef PLUGIN_MAIN
free_osimodules_t __free_osimodules = NULL;
#endif
static inline void free_osimodules(OsiModules *ms);
static inline void free_osimodules(OsiModules *ms) {
    assert(__free_osimodules);
    return __free_osimodules(ms);
}

bool init_osi_api(void);

#ifdef PLUGIN_MAIN
#define API_PLUGIN_NAME "osi"
#define IMPORT_PPP(module, func_name) { \
    __##func_name = (func_name##_t) dlsym(module, #func_name); \
    char *err = dlerror(); \
    if (err) { \
        printf("Couldn't find %s function in library %s.\n", #func_name, API_PLUGIN_NAME); \
        printf("Error: %s\n", err); \
        return false; \
    } \
}
bool init_osi_api(void) {
    void *module = panda_get_plugin_by_name(API_PLUGIN_NAME);
    if (!module) {
        fprintf(stderr, "Couldn't load %s plugin: %s\n", API_PLUGIN_NAME, dlerror());
        return false;
    }
    IMPORT_PPP(module, get_processes)
    IMPORT_PPP(module, get_current_process)
    IMPORT_PPP(module, get_modules)
    IMPORT_PPP(module, get_libraries)
    IMPORT_PPP(module, free_osiproc)
    IMPORT_PPP(module, free_osiprocs)
    IMPORT_PPP(module, free_osimodules)
    return true;
}
#undef API_PLUGIN_NAME
#undef IMPORT_PPP
#endif

#endif
